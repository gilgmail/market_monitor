<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>å¸‚å ´ç›£æ§é¢æ¿ â€” NVDA / SMCI / QQQ</title>
  <link rel="stylesheet" href="static/style.css">
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
</head>
<body>
<header class="hd">
  <h1>å¸‚å ´ç›£æ§é¢æ¿ <span>NVDA / SMCI / QQQ</span></h1>
  <div class="header-info">
    <div class="updated" id="updated">è¼‰å…¥ä¸­â€¦</div>
    <div class="actions">
      <button class="refresh-btn" id="refreshBtn" onclick="manualRefresh()" title="æ‰‹å‹•æ›´æ–°è³‡æ–™">
        <span class="btn-icon">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
            <path d="M13.65 2.35C12.2 0.9 10.21 0 8 0 3.58 0 0.01 3.58 0.01 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L9 7h7V0l-2.35 2.35z"/>
          </svg>
        </span>
        <span>æ›´æ–°è³‡æ–™</span>
      </button>
      <button class="refresh-btn ai-btn" id="aiRefreshBtn" onclick="triggerAIRefresh()" title="é‡æ–°ç”¢ç”Ÿ AI åˆ†æ">
        <span class="btn-icon">ğŸ¤–</span>
        <span>AI åˆ†æ</span>
      </button>
    </div>
  </div>
  <div class="countdown-bar">
    <div class="countdown-progress" id="countdownProgress"></div>
  </div>
  <div class="schedule-info">
    <div class="next-update" id="nextUpdate">ä¸‹æ¬¡æ›´æ–°ï¼šè¨ˆç®—ä¸­â€¦</div>
    <div class="ai-status" id="aiStatus">AI æ›´æ–°ï¼šè¼‰å…¥ä¸­â€¦</div>
  </div>
</header>
<main id="app" class="loading">
  <div class="spinner"></div>
</main>
<footer class="ft">
  ç”± FastAPI æä¾›è³‡æ–™ï¼ŒèƒŒæ™¯æ›´æ–°é »ç‡ï¼š<strong id="dataIntervalLabel">1 åˆ†é˜</strong>ã€‚è³‡æ–™æºï¼šStooqã€Google News RSSã€‚
</footer>
<script>
const basePath = window.location.pathname.replace(/\/$/, '');
let INTERVAL_MS = 60000;
let autoRefreshTimer = null;
let nextUpdateTime = null;
let countdownInterval = null;
let previousData = {};

function restartAutoRefresh() {
  if (autoRefreshTimer) {
    clearInterval(autoRefreshTimer);
  }
  autoRefreshTimer = setInterval(() => {
    loadData().catch(() => {});
  }, INTERVAL_MS);
}

function setAiStatus(text) {
  const el = document.getElementById('aiStatus');
  if (el) {
    el.textContent = text;
  }
}

function applyMeta(meta = {}) {
  const sec = meta.data_interval_sec ?? (meta.interval_min ? meta.interval_min * 60 : null);
  if (sec) {
    const newMs = sec * 1000;
    const intervalChanged = newMs !== INTERVAL_MS;
    INTERVAL_MS = newMs;
    if (intervalChanged || autoRefreshTimer === null) {
      restartAutoRefresh();
    }
    const label = document.getElementById('dataIntervalLabel');
    if (label) {
      if (sec >= 60) {
        const minutes = sec / 60;
        label.textContent = `${minutes % 1 === 0 ? minutes.toFixed(0) : minutes.toFixed(1)} åˆ†é˜`;
      } else {
        label.textContent = `${sec} ç§’`;
      }
    }
  }

  const lastAI = meta.ai_last_generated_local;
  const runCount = meta.ai_total_runs ?? 0;
  const tickerCount = meta.ai_total_ticker_runs ?? 0;
  const detail =
    runCount > 0
      ? `ï¼ˆç¸½æ›´æ–° ${runCount.toLocaleString()} æ¬¡ / å‘¼å« ${tickerCount.toLocaleString()} æ¬¡ï¼‰`
      : 'ï¼ˆå°šæœªä½¿ç”¨ï¼‰';
  setAiStatus(`AI æ›´æ–°ï¼š${lastAI || 'å°šæœªç”¢ç”Ÿ'} ${detail}`);
}

function updateCountdown() {
  if (!nextUpdateTime || INTERVAL_MS <= 0) return;
  const now = Date.now();
  const remaining = Math.max(0, nextUpdateTime - now);
  const seconds = Math.floor(remaining / 1000);
  const minutes = Math.floor(seconds / 60);
  const secs = seconds % 60;

  document.getElementById('nextUpdate').textContent =
    `ä¸‹æ¬¡æ›´æ–°ï¼š${minutes}:${secs.toString().padStart(2, '0')}`;

  const progress = ((INTERVAL_MS - remaining) / INTERVAL_MS) * 100;
  document.getElementById('countdownProgress').style.width = `${progress}%`;

  if (remaining === 0) {
    clearInterval(countdownInterval);
  }
}

async function loadData(isManual = false) {
  const app = document.getElementById('app');
  const refreshBtn = document.getElementById('refreshBtn');

  if (isManual) {
    refreshBtn?.classList.add('spinning');
  }

  try {
    const res = await fetch(`${basePath}/data/dashboard.json?_=${Date.now()}`);
    const data = await res.json();
    applyMeta(data.meta || {});

    document.getElementById('updated').textContent =
      'æœ€å¾Œæ›´æ–°ï¼š' + (data.generated_at_local || 'â€”');

    app.classList.remove('loading');
    app.innerHTML = '';

    const order = Object.keys(data.tickers || {});
    for (const tk of order) {
      const d = data.tickers[tk];
      const px = d.price && d.price.price != null ? d.price.price : null;
      const pxDisplay = px != null ? px.toLocaleString() : 'â€”';
      const curr = d.price && d.price.currency ? d.price.currency : '';
      const ex = d.price && d.price.exchange ? d.price.exchange : '';

      // Price change indicator
      let changeIndicator = '';
      if (previousData[tk] && px != null && previousData[tk].price != null) {
        const prevPx = previousData[tk].price;
        if (px > prevPx) {
          changeIndicator = '<span class="price-change up">â–²</span>';
        } else if (px < prevPx) {
          changeIndicator = '<span class="price-change down">â–¼</span>';
        }
      }

      // AI Analysis
      const ai = d.ai_analysis || {};
      const trendClass = ai.trend === 'bullish' ? 'bullish' : ai.trend === 'bearish' ? 'bearish' : 'neutral';
      const trendIcon = ai.trend === 'bullish' ? 'ğŸ“ˆ' : ai.trend === 'bearish' ? 'ğŸ“‰' : 'â¡ï¸';

      // Stats
      const stats = d.history?.stats || {};
      const changePct = stats.change_percent || 0;
      const changePctClass = changePct > 0 ? 'positive' : changePct < 0 ? 'negative' : '';

      const card = document.createElement('section');
      card.className = 'card fade-in';
      const chartId = `chart-${tk}`;

      card.innerHTML = `
        <div class="row">
          <h2>${tk}</h2>
          <div class="ex">${ex}</div>
        </div>
        <div class="price-wrapper">
          <div class="price">${pxDisplay}<span class="ccy">${curr}</span></div>
          ${changeIndicator}
        </div>

        ${stats.change_percent != null ? `
          <div class="stats-row">
            <div class="stat">
              <div class="stat-label">æ—¥è®ŠåŒ–</div>
              <div class="stat-value ${changePctClass}">${changePct > 0 ? '+' : ''}${changePct}%</div>
            </div>
            <div class="stat">
              <div class="stat-label">30å¤©é«˜é»</div>
              <div class="stat-value">${stats.high_30d ? stats.high_30d.toLocaleString() : 'â€”'}</div>
            </div>
            <div class="stat">
              <div class="stat-label">30å¤©ä½é»</div>
              <div class="stat-value">${stats.low_30d ? stats.low_30d.toLocaleString() : 'â€”'}</div>
            </div>
          </div>
        ` : ''}

        ${d.history && d.history.dates && d.history.dates.length > 0 ? `
          <div class="chart-container">
            <canvas id="${chartId}"></canvas>
          </div>
        ` : ''}

        ${ai.summary ? `
          <div class="ai-analysis ${trendClass}">
            <div class="ai-header">
              <span class="ai-icon">${trendIcon}</span>
              <span class="ai-title">AI åˆ†æ</span>
            </div>
            <div class="ai-summary">${ai.summary}</div>
            ${ai.key_points && ai.key_points.length > 0 ? `
              <ul class="ai-points">
                ${ai.key_points.map(p => `<li>${p}</li>`).join('')}
              </ul>
            ` : ''}
          </div>
        ` : ''}

        <ul class="news">
          ${(d.news||[]).map(n => `
            <li>
              <a href="${n.link}" target="_blank" rel="noopener noreferrer">${n.title}</a>
              <div class="hint">${n.published || ''}</div>
            </li>
          `).join('')}
        </ul>
      `;
      app.appendChild(card);

      // Create chart if data exists
      if (d.history && d.history.dates && d.history.dates.length > 0) {
        const ctx = document.getElementById(chartId);
        if (ctx) {
          const gradient = ctx.getContext('2d').createLinearGradient(0, 0, 0, 200);
          gradient.addColorStop(0, 'rgba(78, 161, 255, 0.3)');
          gradient.addColorStop(1, 'rgba(78, 161, 255, 0)');

          new Chart(ctx, {
            type: 'line',
            data: {
              labels: d.history.dates,
              datasets: [{
                label: 'æ”¶ç›¤åƒ¹',
                data: d.history.prices,
                borderColor: '#4ea1ff',
                backgroundColor: gradient,
                borderWidth: 2,
                fill: true,
                tension: 0.4,
                pointRadius: 0,
                pointHoverRadius: 5,
                pointHoverBackgroundColor: '#4ea1ff',
                pointHoverBorderColor: '#fff',
                pointHoverBorderWidth: 2
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              interaction: {
                intersect: false,
                mode: 'index'
              },
              plugins: {
                legend: { display: false },
                tooltip: {
                  backgroundColor: 'rgba(22, 26, 34, 0.95)',
                  titleColor: '#e7e9ee',
                  bodyColor: '#e7e9ee',
                  borderColor: '#4ea1ff',
                  borderWidth: 1,
                  padding: 10,
                  displayColors: false,
                  callbacks: {
                    label: (context) => `${context.parsed.y.toLocaleString()} ${curr}`
                  }
                }
              },
              scales: {
                x: {
                  display: true,
                  grid: { color: '#232a3a', drawBorder: false },
                  ticks: {
                    color: '#9aa4b2',
                    maxTicksLimit: 6,
                    font: { size: 10 }
                  }
                },
                y: {
                  display: true,
                  grid: { color: '#232a3a', drawBorder: false },
                  ticks: {
                    color: '#9aa4b2',
                    font: { size: 10 },
                    callback: (value) => value.toLocaleString()
                  }
                }
              }
            }
          });
        }
      }

      // Store current price for next comparison
      if (px != null) {
        previousData[tk] = { price: px };
      }
    }

    // Set next update time
    nextUpdateTime = Date.now() + INTERVAL_MS;
    if (countdownInterval) clearInterval(countdownInterval);
    countdownInterval = setInterval(updateCountdown, 1000);
    updateCountdown();

  } catch (e) {
    document.getElementById('updated').textContent = 'è¼‰å…¥å¤±æ•—ï¼š' + e.message;
    app.classList.remove('loading');
    app.innerHTML = '<div class="error">è³‡æ–™è¼‰å…¥å¤±æ•—ï¼Œè«‹ç¨å¾Œé‡è©¦</div>';
  } finally {
    if (isManual && refreshBtn) {
      setTimeout(() => refreshBtn.classList.remove('spinning'), 500);
    }
  }
}

async function manualRefresh() {
  await loadData(true);
}

async function triggerAIRefresh() {
  const btn = document.getElementById('aiRefreshBtn');
  if (btn) {
    btn.disabled = true;
    btn.classList.add('spinning');
  }
  setAiStatus('AI æ›´æ–°ï¼šç”Ÿæˆä¸­â€¦');
  try {
    const res = await fetch(`${basePath}/trigger/ai`, { method: 'POST' });
    if (!res.ok) {
      throw new Error(`HTTP ${res.status}`);
    }
    await res.json();
    await loadData();
  } catch (e) {
    setAiStatus('AI æ›´æ–°ï¼šå¤±æ•—ï¼Œè«‹ç¨å¾Œé‡è©¦');
    alert('AI åˆ†ææ›´æ–°å¤±æ•—ï¼š' + e.message);
  } finally {
    if (btn) {
      btn.disabled = false;
      setTimeout(() => btn.classList.remove('spinning'), 300);
    }
  }
}

// Initial load
loadData();

// Ensure auto refresh is scheduled after first metadata sync
restartAutoRefresh();
</script>
</body>
</html>
